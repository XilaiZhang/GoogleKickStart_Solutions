1. imageLabeler.py: We use a greedy approach to group up the smallest numbers, and leave the larger groups independent. See official analysis for proof. <br /><br />
2. MaximumGain.py: A dp solution would be insufficient. Instead, the two sums from both ends remind us of the classic two sum problem. So we create a prefix sum array and a postfix sum array, and compute the optimal two sum for array a and b. eventually combine the two-sum-s from the two arrays.<br /><br />
3. TouchbarTyping.py: The key observation is that when moving from character i to character i+1 in string S, we always move to the closest next position on keyboard. This reduces our time complexity of transitioning through dp relation to O(1). The detail of dp relation and proof can be found in official analysis.<br />
To implement the O(1) transition, similar to the classic trapping rain water problem, I maintained a minimum distance array left_array, and a minimum distance array right_array. each value in left_array represents the smallest next position to the left of the current position. As we move from left to right, we update left_array[i] to 0 if we encounter a smaller value, otherwise we increment the distance by 1 (left_array[i] = left_array[i-1]+1). The right_array can be updated similarly by iterating from right to left. The time complexity of maintaining the two arrays is O(M) as we travel the O(MN) of dp states, but by maintaining the arrays we transit with O(1) time complexity through the dp states. <br /><br />
4. SuspectsAndWitness.cpp: The key observation is to find witness of size greater than K. To set the correct number of witnesses, we perform a topological sort. And to perform a topological sort, we need to clear out all the strongly connected components. <br />
Aside from official analysis, here are the things to notice: <br /><br />
  i.  python will reach maximum recursion depth easily, so use c++ instead. the scc algorithm requires a recursive approach.<br />
  ii.  when adding up the number of witnesses, do not add duplicate. This can be achieved by adding to a \<set> of witness, instead of a \<list> of witness. <br />
  iii.  when composing in-node degree for topological sort, do not duplicate the multiple edges that connect between two clusters.<br />
<br /><br /> With all those in mind, convert graph into a graph of scc clusters, and perform a topological sort on the graph of scc clusters, to eventually compute out the witness number.
