imageLabeler.py: We use a greedy approach to group up the smallest numbers, and leave the larger groups independent. See official analysis for proof. <br /><br />
MaximumGain.py: A dp solution would be insufficient. Instead, the two sums from both ends remind us of the classic two sum problem. So we create a prefix sum array and a postfix sum array, and compute the optimal two sum for array a and b. eventually combine the two-sum-s from the two arrays.<br /><br />
TouchbarTyping.py: The key observation is that when moving from character i to character i+1 in string S, we always move to the closest next position on keyboard. This reduces our time complexity of transitioning through dp relation to O(1). The detail of dp relation and proof can be found in official analysis.<br />
To implement the O(1) transition, similar to the classic trapping rain water problem, I maintained a minimum distance array left_array, and a minimum distance array right_array. each value in left_array represents the smallest next position to the left of the current position. As we move from left to right, we update left_array[i] to 0 if we encounter a smaller value, otherwise we increment the distance by 1 (left_array[i] = left_array[i-1]+1). The right_array can be updated similarly by iterating from right to left. The time complexity of maintaining the two arrays is O(M) as we travel the O(MN) of dp states, but by maintaining the arrays we transit with O(1) time complexity through the dp states. <br /><br />
I will write up the last problem after dinner.
